<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>EL表达式 - Fatkun&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="fatkun" /><meta name="description" content="期待已久的日子即将到来: 最新版JavaServer Pages (JSP)2.0 规范即将和其他的J2EE 1.4一同发布。新的JSP版本有一个新的飞跃，采用了新的方式：" /><meta name="keywords" content="Hugo, fatkun" />






<meta name="generator" content="Hugo 0.70.0 with theme even" />


<link rel="canonical" href="https://fatkun.github.io/2010/11/el-expression.html" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f8d981be68d2538153a6e4ce23201045e9549712aa5905499cc22691b43378b0.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="EL表达式" />
<meta property="og:description" content="期待已久的日子即将到来: 最新版JavaServer Pages (JSP)2.0 规范即将和其他的J2EE 1.4一同发布。新的JSP版本有一个新的飞跃，采用了新的方式：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fatkun.github.io/2010/11/el-expression.html" />
<meta property="article:published_time" content="2010-11-19T15:14:26+00:00" />
<meta property="article:modified_time" content="2010-11-19T15:14:26+00:00" />
<meta itemprop="name" content="EL表达式">
<meta itemprop="description" content="期待已久的日子即将到来: 最新版JavaServer Pages (JSP)2.0 规范即将和其他的J2EE 1.4一同发布。新的JSP版本有一个新的飞跃，采用了新的方式：">
<meta itemprop="datePublished" content="2010-11-19T15:14:26&#43;00:00" />
<meta itemprop="dateModified" content="2010-11-19T15:14:26&#43;00:00" />
<meta itemprop="wordCount" content="5698">



<meta itemprop="keywords" content="el,JAVA,JSTL," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="EL表达式"/>
<meta name="twitter:description" content="期待已久的日子即将到来: 最新版JavaServer Pages (JSP)2.0 规范即将和其他的J2EE 1.4一同发布。新的JSP版本有一个新的飞跃，采用了新的方式："/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Fatkun&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">存档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Fatkun&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">存档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">EL表达式</h1>

      <div class="post-meta">
        <span class="post-time"> 2010-11-19 </span>
        <div class="post-category">
            <a href="/categories/j2ee/"> J2EE </a>
            </div>
          <span class="more-meta"> 约 5698 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>期待已久的日子即将到来: 最新版<a href="http://java.sun.com/products/jsp/">JavaServer Pages (JSP)</a>2.0 规范即将和其他的J2EE 1.4一同发布。新的JSP版本有一个新的飞跃，采用了新的方式：由于新的语言表达式（Expression Language，以下简称为EL）和JSP标准标签库（JSP Standard Tag Library ,以下简称为JSTL）这两种新的方式，在页面中不需要用java,对于开发一般的应用来说，重用代码变得更加容易。更具体来说，JSP 2.0带来了以下的优点：</p>
<ul>
<li>首次被JSTL 1.0引入的EL现在被合并到JSP规范中，就像应用template text一样地使用所有的标准的和定制的组件。</li>
<li>新的EL已经被扩展，具备一个函数调用机制，JSTL1.1整合了一系列经常需要使用的函数。</li>
<li>新增加的变量和servlet 规范定义的错误处理机制被更好地组织起来。通过新增加的变量，JSP error pages 现在可以提供更多的错误信息。</li>
<li>容器因为更加严格的语法检查可以更容易地找出发生的错误。</li>
<li>所有的J2EE 1.4规范（包括JSP 2.0 和 Servlet 2.4），为了声明部署的规则描述而应用了XML schema。这样的好处之一是你现在可以通过任何顺序列出web.xml文件中的描述。JSP 2.0也增加了一些新的配置选项用于部署描述，允许通过全局的配置来代替基于每页的配置。</li>
<li>由于更具伸缩性的规则和新的自定义action element，现在就像编写XML文件一样，编写JSP页面变得更加容易。</li>
<li>定制的标签库现在可以开发成一系列的标签文件（具有JSP元素的文本文件），标签处理器可以使用新的、简化的标签处理器的API。与此同时，新规范加入了一些新的特性，比如：支持在jsp页面上显示动态属性列表和可执行片断属性。
在众多的书籍中，这是头一个讲解JSP 2.0新特性的文章。在这一部分，我们将看到和EL相关的信息，其他的新特性留到后面。在这里我假定读者已经熟悉JSP 1.2，而且至少听说过JSTL。
你可能对这本第三版的《JavaServer Pages》感兴趣。这本书中，我尽可能在细节上讲述所有的内容，而且并不认为你对JSP或者JSTL了解一切。这本书预计在2003年12月 出版，但是你现在可以在<a href="http://www.amazon.com/">http://www.amazon.com</a>、Barnes&amp;Noble，或者其他在线书店预订。
EL(The Expression Language)
如果过去使用过JSTL，那么你可能已经熟悉 了EL。EL在JSTL 1.0规范中被引入，用来在运行期间对Java表达式中action element属性赋值提供另一种选择。当JSTL EL已经非常迅速的流行起来情况下，还是存在一个问题： JSTL EL 表达式仅仅可以与JSTL和custom action一起使用，怎样才能使用非标准API对EL表达式求值？
JSP 2.0中,JSP容器自己可以理解EL表达式。这使你在所有过去只能应用Java表达式的地方应用EL表达式成为可能，比如：标准和定制action的属性值，模板文本。
在我们看具体的例子前，让我们更进一步的看看 什么是EL。EL是从JavaScript中获得启发的一种语言，XPath(一种用来访问XML文档的语言)，但是EL在对变量的null值和执行更多 数据类型的自动类型转换的处理上更加宽松。这些新特性对于web应用非常重要，在这些应用中输入通常通过html表单的request parameter来得到。这些参数可能仅仅在某些请求下才能体现出来，而且浏览器经常将request parameter作为文本发送，然而应用程序经常需要把他们作为数字类型、布尔类型（true 或者 false）来使用。通过EL，你根本就很少需要关心缺少某些参数的值或者类型转换。
一个EL表达式包含变量和操作符。任何存储在某个JSP作用范围(如：page、 request、session、application)的bean能被作为一个EL变量来使用。另外，EL支持以下预定义的变量：</li>
</ul>
<table border="1" cellspacing="0" cellpadding="0">  <tr>    <td>      变量名称    </td>
    <td>      说明    </td>  </tr>
  <tr>    <td valign="top">      pageScope    </td>
    <td>      一个包含所有page scope范围的变量集合 (a java.util.Map)    </td>  </tr>
  <tr>    <td valign="top">      requestScope    </td>
    <td>      一个包含所有request scope范围的变量集合 (a java.util.Map)    </td>  </tr>
  <tr>    <td valign="top">      sessionScope    </td>
    <td>      一个包含所有session scope范围的变量集合 (a java.util.Map)    </td>  </tr>
  <tr>    <td valign="top">      applicationScope    </td>
    <td>      一个包含所有application scope范围的变量集合 (a java.util.Map)    </td>  </tr>
  <tr>    <td valign="top">      param    </td>
    <td>      一个包含所有请求参数的集合 (a java.util.Map)，通过每个参数对应一个String值的方式赋值    </td>  </tr>
  <tr>    <td valign="top">      paramValues    </td>
    <td>      一个包含所有请求参数的集合 (a java.util.Map)，通过每个参数对应一个String数组的方式赋值    </td>  </tr>
  <tr>    <td valign="top">      header    </td>
    <td>      一个包含所有请求的头信息的集合， (a java.util.Map) ,通过每个头信息对应一个String值的方式赋值    </td>  </tr>
  <tr>    <td valign="top">      headerValues    </td>
    <td>      一个包含所有请求的头信息的集合 (a java.util.Map) ，通过每个头信息的值都保存在一个String数组的方式赋值    </td>  </tr>
  <tr>    <td valign="top">      cookie    </td>
    <td>      一个包含所有请求的 cookie集合 (a java.util.Map)，    通过每一个cookie（javax.servlet.http.Cookie）对应一个cookie值的方式赋值    </td>  </tr>
  <tr>    <td valign="top">      initParam    </td>
    <td>      一个包含所有应用程序初始化参数的集合(a java.util.Map) ，通过每个参数分别对应一个String值的方式赋值    </td>  </tr>
  <tr>    <td valign="top">      pageContext    </td>
    <td>      一个javax.servlet.jsp.PageContext类的实例, 用来提供访问不同的请求数据    </td>  </tr></table>
操作符描述了你对变量所期望的操作。如果你之前曾经使用过任何编程语言的话，在EL表达式中所使用的操作符对你来说可能看起来很熟悉。因为它们和那些在大多数语言中所支持的操作符一样。
<table border="1" cellspacing="0" cellpadding="0">  <tr>    <td>      Operator    </td>
    <td>      Description    </td>  </tr>
  <tr>    <td valign="top">      .    </td>
    <td>      访问一个bean属性或者 Map entry    </td>  </tr>
  <tr>    <td valign="top">      []    </td>
    <td>      访问一个数组或者链表元素    </td>  </tr>
  <tr>    <td valign="top">      ()    </td>
    <td>      对子表达式分组，用来改变赋值顺序    </td>  </tr>
  <tr>    <td valign="top">      ? :    </td>
    <td>      条件语句，比如: 条件 ? ifTrue : ifFalse.如果条件为真，表达式值为前者，反之为后者    </td>  </tr>
  <tr>    <td valign="top">      +    </td>
    <td>      数学运算符，加操作    </td>  </tr>
  <tr>    <td valign="top">      &#8211;    </td>
    <td>      数学运算符，减操作或者对一个值取反    </td>  </tr>
  <tr>    <td valign="top">      *    </td>
    <td>      数学运算符，乘操作    </td>  </tr>
  <tr>    <td valign="top">      / or div    </td>
    <td>      数学运算符，除操作    </td>  </tr>
  <tr>    <td valign="top">      % or mod    </td>
    <td>      数学运算符，模操作(取余)    </td>  </tr>
  <tr>    <td valign="top">      == or eq    </td>
    <td>      逻辑运算符，判断符号左右两端是否相等，如果相等返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      != or ne    </td>
    <td>      逻辑运算符，判断符号左右两端是否不相等，如果不相等返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      < or lt    </td>
    <td>      逻辑运算符，判断符号左边是否小于右边，如果小于返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      > or gt    </td>
    <td>      逻辑运算符，判断符号左边是否大于右边，如果大于返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      <= or le    </td>
    <td>      逻辑运算符，判断符号左边是否小于或者等于右边，如果小于或者等于返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      >= or ge    </td>
    <td>      逻辑运算符，判断符号左边是否大于或者等于右边，如果大于或者等于返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      && or and    </td>
    <td>      逻辑运算符，与操作赋。如果左右两边同为true返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      || or or    </td>
    <td>      逻辑运算符，或操作赋。如果左右两边有任何一边为true返回true，否则返回false    </td>  </tr>
  <tr>    <td valign="top">      ! or not    </td>
    <td>      逻辑运算符，非操作赋。如果对true取运算返回false，否则返回true    </td>  </tr>
  <tr>    <td valign="top">      empty    </td>
    <td>      用来对一个空变量值进行判断: null、一个空String、空数组、 空Map、没有条目的Collection集合    </td>  </tr>
  <tr>    <td valign="top">      func(args)    </td>
    <td>      调用方法, func是方法名，args是参数，可以没有，或者有一个、多个参数.参数间用逗号隔开    </td>  </tr></table>
一个EL表达式可以包含：数字、文本（在单引号或者双引号之间）、布尔值、null值。
因为一个EL表达式可以出现在静态文本出现的 地方，因此你必须告诉JSP容器它应该被当作一个EL表达式来处理。你可以通过使用定界符来做到这一点。一个EL表达式总是以”${ }”来标记（一个“$”符号和一个左花括号,右花括号）。这里有一个EL表达式，它将一个命名为amount的变量加5：
${amount + 5}
如果你想要将5加到一个bean的property上，可以使用property访问操作符：
${order.amount + 5}
在当前这个指定的bean或者collection集合中，Property访问操作符（一个“.“符号）告诉EL去寻找名字为amount的property。
${order[&#8216;amount&#8217;] + 5}
在[]之间的值必须是一个property的名字（就像上面的例子中那样）或者是一个保存property名字的变量（或者是一个完整的EL子表达式）。
EL表达式可以被用来赋值给任何标准的或者定制的JSP行为属性（action attribute），这些行为属性被标记为可以接受动态值（或者请求期间的属性值，就象它被正式调用一样）：
<c:out value=&#8221;${order.amount + 5}&#8221;/>
在JSP 2.0之前，你不得不使用Java表达式去给一个属性动态赋值。在过去的很多年中，这已经成为语法混乱的一个普遍根源。
最后，EL表达式可以在页面中和模板直接混合使用。当你生成HTML并且需要设置一个动态值给一个属性的时候，这非常方便：
<input name=&#8221;firstName&#8221; value=&#8221;${customer.firstName}&#8221;>
JSP 1.2中，你不得不使用JSTL的<c:out>来实现同样的事情，最后把各种不同类型的元素混合起来，这导致程序理解起来非常的困难：
<input name=&#8221;firstName&#8221;
value=&#8221;<c:out value=&#8221;${customer.firstName}&#8221;/>&#8221; >
新JSTL 1.1 Tag Library 标识符
JSTL1.1发布的是一个初级的版本，主要 目的是用来整合JSTL和JSP2.0 。最明显的变化是JSTL1.0 “孪生函数库”（一组库用来接受EL表达式，另外一组用来接受JAVA表达式），而它们已经被一组既可以用于EL表达式也可以用于JAVA表达式的函数库 所代替。
在JSTL 1.1中使用以下标识符:
<table border="1" cellspacing="0" cellpadding="0">  <tr>    <td>      库    </td>
    <td>      URI    </td>
    <td>      前缀    </td>  </tr>
  <tr>    <td>      Core    </td>
    <td>      http://java.sun.com/jsp/jstl/core    </td>
    <td>      c    </td>  </tr>
  <tr>    <td>      XML processing    </td>
    <td>      http://java.sun.com/jsp/jstl/xml    </td>
    <td>      x    </td>  </tr>
  <tr>    <td>      I18N formatting    </td>
    <td>      http://java.sun.com/jsp/jstl/fmt    </td>
    <td>      fmt    </td>  </tr>
  <tr>    <td>      Database access    </td>
    <td>      http://java.sun.com/jsp/jstl/sql    </td>
    <td>      sql    </td>  </tr>
  <tr>    <td>      Functions    </td>
    <td>      http://java.sun.com/jsp/jstl/functions    </td>
    <td>      fn    </td>  </tr></table>
如果你曾经使用过JSTL1.0，你可能会注意到新的标识符和旧的EL库标试符一模一样，除了加入了“/jsp path” element。你也可能注意到在JSTL1.1中有一个库，包含了EL的函数。我们稍后就会看到。
一个新的EL操作符
在JSP页面中一个非常普遍的需求就是：当某 个条件为真时，要在网页中包含一些文字。在JSP1.2和JSTL1.1中，用具有代表性的<c:if>来实现，但是这样做非常繁琐。 JSP2.0增加了一个新的条件操作符用于EL，以更加优雅的方式来处理这样的情况。这个条件操作符存在于很多编程语言中（比 如：Java,C,JavaScript）,因此你可能以前就见过它。它判断一个布尔的条件，当条件为真或者假时，分别取不同的结果。
一个能清楚说明它如何工作的例子：
<select name=&#8221;artist&#8221;>
<option value=&#8221;1&#8243; ${param.artist == 1 ? &#8216;selected&#8217; : &#8221;}>
Vesica Pisces
<option value=&#8221;2&#8243; ${param.artist == 2 ? &#8216;selected&#8217; : &#8221;}>
Cortical Control
<option value=&#8221;3&#8243; ${param.artist == 3 ? &#8216;selected&#8217; : &#8221;}>
Vida Vierra
</select>
在这里，我使用了EL表达式和条件操作符来选 择是否包含 html 中的 “selected”属性，只有符合条件的 “option” 才被添加 “selected” 属性。如果条件（param.artist==1）为真时，前面的“selected” 才被添加到网页中；否则就添加后面的（在这里是空字符串 ‘’）到页面中。
EL函数
当EL从JSTL规范中移到JSP规范中，它使用了一个如何进行函数调用的技巧。这个EL函数语法非常简单：方法名，紧接着在圆括号中有一组参数：<%@ taglib prefix=&#8221;fn&#8221;
uri=&#8221;http://java.sun.com/jsp/jstl/functions&#8221; %>
${fn:length(myCollection)}
这是一个属于标签库中的函数,并且函数名字在页面中所包含的前缀要指定taglib库。在这个例子中，我使用了前缀fn,这是JSTL function库默认的前缀。
标签库描述符（Tag Library Descriptor,TLD）将函数名称映射到一个由JAVA实现的静态方法中：<function>
<description>
Returns the number of items in a collection or the number of characters in a string.
</description>
<name>length</name>
<function-class>
org.apache.taglibs.standard.functions.Functions
</function-class>
<function-signature>
int length(java.lang.Object)
</function-signature>
</function>
在这里最有趣的element 是<function-signature>。它包含一个函数返回类型的声明，静态的方法的名字，在圆括号中声明该方法所有参数的类型（可以 没有参数或者有多个，参数间用逗号间隔开）。返回值类型和参数类型必须是java的原始类型（Object）或者是其他合法类型。
这个静态方法 length()在Jakarta Taglibs标准库中用类似于下面的代码实现的：
<pre escaped="true" lang="java" line="1">public static int length(Object obj)
<p>throws JspTagException {</p>
<p>if (obj == null)</p>
<p>return 0;</p>
<p>if (obj instanceof String)</p>
<p>return ((String)obj).length();</p>
<p>if (obj instanceof Collection)</p>
<p>return ((Collection)obj).size();</p>
<p>if (obj instanceof Map)</p>
<p>return ((Map)obj).size();</p>
<p>int count = 0;</p>
<p>if (obj instanceof Iterator) {</p>
<p>Iterator iter = (Iterator) obj;</p>
<p>count = 0;</p>
<p>while (iter.hasNext()) {</p>
<p>count++;</p>
<p>iter.next();</p>
<p>}</p>
<p>return count;</p>
<p>}</p>
<p>if (obj instanceof Enumeration) {</p>
<p>Enumeration enum = (Enumeration) obj;</p>
<p>count = 0;</p>
<p>while (enum.hasMoreElements()) {</p>
<p>count++;</p>
<p>enum.nextElement();</p>
<p>}</p>
<p>return count;</p>
<p>}</p>
<p>try {</p>
<p>count = Array.getLength(obj);</p>
<p>return count;</p>
<p>} catch (IllegalArgumentException ex) {}</p>
<p>throw new JspTagException(&ldquo;Unsupported type&rdquo;));</p>
<p>}</pre>
就像你所看到的，在那里没有什么出奇的地方。它是一个常规的静态方法，这个函数中通过对运行期中的参数类别的判断，找出参数的长度。
除了在这个方法中使用的length()方法，JSTL1.1标签库还包含了许多其它经常使用的函数：</p>
<table border="1" cellspacing="0" cellpadding="0">  <tr>    <td>      函数    </td>
    <td>      描述    </td>  </tr>
  <tr>    <td valign="top">      fn:contains(string, substring)    </td>
    <td>      如果参数string中包含参数substring，返回true    </td>  </tr>
  <tr>    <td valign="top">      fn:containsIgnoreCase(string, substring)    </td>
    <td>      如果参数string中包含参数substring（忽略大小写），返回true    </td>  </tr>
  <tr>    <td valign="top">      fn:endsWith(string, suffix)    </td>
    <td>      如果参数 string 以参数suffix结尾，返回true    </td>  </tr>
  <tr>    <td valign="top">      fn:escapeXml(string)    </td>
    <td>      将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回    </td>  </tr>
  <tr>    <td valign="top">      fn:indexOf(string, substring)    </td>
    <td>      返回参数substring在参数string中第一次出现的位置    </td>  </tr>
  <tr>    <td valign="top">      fn:join(array, separator)    </td>
    <td>      将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。    </td>  </tr>
  <tr>    <td valign="top">      fn:length(item)    </td>
    <td>      返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。    </td>  </tr>
  <tr>    <td valign="top">      fn:replace(string, before, after)    </td>
    <td valign="top">      返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果    </td>  </tr>
  <tr>    <td valign="top">      fn:split(string, separator)    </td>
    <td>      返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素    </td>  </tr>
  <tr>    <td valign="top">      fn:startsWith(string, prefix)    </td>
    <td>      如果参数string以参数prefix开头，返回true    </td>  </tr>
  <tr>    <td valign="top">      fn:substring(string, begin, end)    </td>
    <td>      返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置的字符    </td>  </tr>
  <tr>    <td valign="top">      fn:substringAfter(string, substring)    </td>
    <td>      返回参数substring在参数string中后面的那一部分字符串    </td>  </tr>
  <tr>    <td valign="top">      fn:substringBefore(string, substring)    </td>
    <td>      返回参数substring在参数string中前面的那一部分字符串    </td>  </tr>
  <tr>    <td valign="top">      fn:toLowerCase(string)    </td>
    <td>      将参数string所有的字符变为小写，并将其返回    </td>  </tr>
  <tr>    <td valign="top">      fn:toUpperCase(string)    </td>
    <td>      将参数string所有的字符变为大写，并将其返回    </td>  </tr>
  <tr>    <td valign="top">      fn:trim(string)    </td>
    <td>      去除参数string 首尾的空格，并将其返回    </td>  </tr></table>
结束语：
在这篇文章中，我从EL讲到JSTL1.1规 范、EL新特色和JSTL 1.1函数库。接下来的部分我将要告诉你：关于JSP error-page的改进和增强； jsp:id 属性带来的益处；新的配置属性描述符；JSP2.0如何使JSP操作XML变得更加容易；自定义标签库的新特性。
如果你想要尝试JSP2.0的新特性，我建议 你使用Apache Tomcat 5。它是最早实现了JSP新规范的容器之一。在公布最终版本的JSP 2.0规范之前，一个被标记为“stable”版本的Tomcat是不能被发布的。但是最新的beta版已经被证实是非常稳定的，不要理会beta版的标 记。Tomcat 5在[the Jakarta Project site][3]可以下载。
[Hans Bergsten][4] is the founder of Gefion Software and author of O&#8217;Reilly&#8217;s [JavaServer Pages, 3rd Edition][5].
Return to [ONJava.com][6].
原文来自：<http://blog.163.com/hbxiaoman_yang/blog/static/916313442009227115939767/>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">fatkun</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2010-11-19
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/el/">el</a>
          <a href="/tags/java/">JAVA</a>
          <a href="/tags/jstl/">JSTL</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2010/11/excanvas.html">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">在IE下动态创建canvas使用excanvas时失效解决方法</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2010/11/dreamweaver-with-regex-replace.html">
            <span class="next-text nav-default">在Dreamweaver使用正则表达式替换</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/fatkun" class="iconfont icon-github" title="github"></a>
  <a href="https://fatkun.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2009 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>fatkun</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
