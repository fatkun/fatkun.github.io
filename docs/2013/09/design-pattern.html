<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>设计模式理解 - Fatkun&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="fatkun" /><meta name="description" content="设计模式学习" /><meta name="keywords" content="Hugo, fatkun" />






<meta name="generator" content="Hugo 0.70.0 with theme even" />


<link rel="canonical" href="https://fatkun.github.io/2013/09/design-pattern.html" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f8d981be68d2538153a6e4ce23201045e9549712aa5905499cc22691b43378b0.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="设计模式理解" />
<meta property="og:description" content="设计模式学习" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://fatkun.github.io/2013/09/design-pattern.html" />
<meta property="article:published_time" content="2013-09-24T15:55:14+00:00" />
<meta property="article:modified_time" content="2013-09-24T15:55:14+00:00" />
<meta itemprop="name" content="设计模式理解">
<meta itemprop="description" content="设计模式学习">
<meta itemprop="datePublished" content="2013-09-24T15:55:14&#43;00:00" />
<meta itemprop="dateModified" content="2013-09-24T15:55:14&#43;00:00" />
<meta itemprop="wordCount" content="4095">



<meta itemprop="keywords" content="设计模式," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="设计模式理解"/>
<meta name="twitter:description" content="设计模式学习"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Fatkun&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">存档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Fatkun&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">存档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">设计模式理解</h1>

      <div class="post-meta">
        <span class="post-time"> 2013-09-24 </span>
        <div class="post-category">
            <a href="/categories/%E7%94%B5%E8%84%91%E7%9F%A5%E8%AF%86/"> 电脑知识 </a>
            </div>
          <span class="more-meta"> 约 4095 字 </span>
          <span class="more-meta"> 预计阅读 9 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#设计模式学习">设计模式学习</a></li>
        <li><a href="#抽象工厂模式">抽象工厂模式</a></li>
        <li><a href="#工厂方法模式简单工厂">工厂方法模式/简单工厂</a></li>
        <li><a href="#生成器模式建造者模式">生成器模式/<strong>建造者模式</strong></a></li>
        <li><a href="#heading"></a></li>
        <li><a href="#对象池模式">对象池模式</a></li>
        <li><a href="#heading-1"></a></li>
        <li><a href="#原型模式">原型模式</a></li>
        <li><a href="#单例模式">单例模式</a></li>
        <li><a href="#heading-2"></a></li>
        <li><a href="#适配器模式">适配器模式</a></li>
        <li><a href="#桥接模式-bridge">桥接模式 /Bridge</a></li>
        <li><a href="#组合模式">组合模式</a></li>
        <li><a href="#装饰模式decorator"><strong>装饰模式/Decorator</strong></a></li>
        <li><a href="#外观模式facadec">外观模式/Facadec</a></li>
        <li><a href="#享元模式flyweight">享元模式/Flyweight</a></li>
        <li><a href="#代理模式proxy">代理模式/Proxy</a></li>
        <li><a href="#解释器模式interpreter">解释器模式/Interpreter</a></li>
        <li><a href="#迭代器">迭代器</a></li>
        <li><a href="#中介者模式">中介者模式</a></li>
        <li><a href="#备忘录模式">备忘录模式</a></li>
        <li><a href="#观察者模式">观察者模式</a></li>
        <li><a href="#状态模式">状态模式</a></li>
        <li><a href="#策略模式">策略模式</a></li>
        <li><a href="#模板模式">模板模式</a></li>
        <li><a href="#访问者模式">访问者模式</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="设计模式学习">设计模式学习</h2>
<h2 id="抽象工厂模式">抽象工厂模式</h2>
<p><strong>场景：</strong> 把同一主题的工厂封装起来，对外提供一致的接口，返回不同的产品。
**使用：**利用接口建立一个抽象工厂，不同的工厂实现这个接口，产出的产品也要有一个接口。在使用时，需要选择具体工厂类（不能new 接口）。
**实例：**提供对不同的数据库访问的支持。IUser和IDepartment是两种不同的抽象产品，它们都有Access和SQL Server这两种不同的实现；IFactory是产生IUser和IDepartment的抽象工厂，根据具体实现（AccessFactory和SqlFactory）产生对应的具体的对象（CAccessUser与CAccessDepartment，或者CSqlUser与CSqlDepartment）。
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Abstract_factory_UML.svg/677px-Abstract_factory_UML.svg.png" alt="File:Abstract factory UML.svg"></p>
<pre lang="python" escaped="true">抽象工厂模式（python）

class IUser:
    def GetUser(self):
        pass

class IDepartment:
    def GetDepartment(self):
        pass

class CAccessUser(IUser):
    def GetUser(self):
        print "Access GetUser"

class CAccessDepartment(IDepartment):
    def GetDepartment(self):
        print "Access GetDepartment"

class CSqlUser(IUser):
    def GetUser(self):
        print "Sql GetUser"

class CSqlDepartment(IDepartment):
    def GetDepartment(self):
        print "Sql GetDepartment"

class IFactory:
    def CreateUser(self):
        pass
    def CreateDepartment(self):
        pass

class AccessFactory(IFactory):
    def CreateUser(self):
        temp=CAccessUser()
        return temp
    def CreateDepartment(self):
        temp = CAccessDepartment()
        return temp

class SqlFactory(IFactory):
    def CreateUser(self):
        temp = CSqlUser()
        return temp
    def CreateDepartment(self):
        temp = CSqlDepartment()
        return temp

if __name__ == "__main__":
    factory = SqlFactory()
    user=factory.CreateUser()
    depart=factory.CreateDepartment()
    user.GetUser()
    depart.GetDepartment()</pre>
<h2 id="工厂方法模式简单工厂">工厂方法模式/简单工厂</h2>
<p>**场景：**创建实体类比较多，抽取出来，根据条件判断要创建哪个实现类。
**使用：**根据不同的参数选择具体的实现类。
**实例：**一个程序要读取图像文件。程序支持多种图像格式，每种格式都有一个对应的<code>ImageReader</code>类用来读取图像。程序每次读取图像时，需要基于文件信息创建合适类型的<code>ImageReader</code>。
 
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/FactoryMethod.svg/300px-FactoryMethod.svg.png" alt=""></p>
<pre lang="java" escaped="true">public class ImageReaderFactory {
    public static ImageReader imageReaderFactoryMethod(InputStream is) {
        ImageReader product = null;

        int imageType = determineImageType(is);
        switch (imageType) {
            case ImageReaderFactory.GIF:
                product = new GifReader(is);
            case ImageReaderFactory.JPEG:
                product = new JpegReader(is);
            //...
        }
        return product;
    }
}</pre>
<h2 id="生成器模式建造者模式">生成器模式/<strong>建造者模式</strong></h2>
<p>**场景：**和抽象工厂类似，创建复杂的对象。生成器着重在一步一步的构造对象。
**使用：**一个Builder抽象类，一个实现Builder类，有多个方法来构造对象。Director是用来使用builder的。
**实例：**制造Pizza
<img src="http://images.cnblogs.com/cnblogs_com/wuyuegb2312/468244/o_ch9.%e5%bb%ba%e9%80%a0%e8%80%85%e6%a8%a1%e5%bc%8f.png" alt=""></p>
<pre lang="java" escaped="true">/** "Product" */
 class Pizza {
   private String dough = "";
   private String sauce = "";
   private String topping = "";

   public void setDough (String dough)     { this.dough = dough; }
   public void setSauce (String sauce)     { this.sauce = sauce; }
   public void setTopping (String topping) { this.topping = topping; }
 }

 ''/** "Abstract Builder" */''
 abstract class PizzaBuilder {
   protected Pizza pizza;

   public Pizza getPizza() { return pizza; }
   public void createNewPizzaProduct() { pizza = new Pizza(); }

   public abstract void buildDough();
   public abstract void buildSauce();
   public abstract void buildTopping();
 }

 /** "ConcreteBuilder" */
 class HawaiianPizzaBuilder extends PizzaBuilder {
   public void buildDough()   { pizza.setDough("cross"); }
   public void buildSauce()   { pizza.setSauce("mild"); }
   public void buildTopping() { pizza.setTopping("ham+pineapple"); }
 }

 /** "ConcreteBuilder" */
 class SpicyPizzaBuilder extends PizzaBuilder {
   public void buildDough()   { pizza.setDough("pan baked"); }
   public void buildSauce()   { pizza.setSauce("hot"); }
   public void buildTopping() { pizza.setTopping("pepperoni+salami"); }
 }

 ''/** "Director" */''
 class Waiter {
   private PizzaBuilder pizzaBuilder;

   public void setPizzaBuilder (PizzaBuilder pb) { pizzaBuilder = pb; }
   public Pizza getPizza() { return pizzaBuilder.getPizza(); }

   public void constructPizza() {
     pizzaBuilder.createNewPizzaProduct();
     pizzaBuilder.buildDough();
     pizzaBuilder.buildSauce();
     pizzaBuilder.buildTopping();
   }
 }

 /** A customer ordering a pizza. */
 class BuilderExample {
   public static void main(String[] args) {
     Waiter waiter = new Waiter();
     PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder();
     PizzaBuilder spicy_pizzabuilder = new SpicyPizzaBuilder();

     waiter.setPizzaBuilder ( hawaiian_pizzabuilder );
     waiter.constructPizza();

     Pizza pizza = waiter.getPizza();
   }
 }</pre>
<p> </p>
<h2 id="firstHeading" lang="zh-CN">  惰性初始模式/惰性工厂</h2>
**场景：**延迟创建对象
**使用：**有一个map来存储创建出来的对象，如果没创建过就创建出来放到map里，否则直接返回。要注意要有锁。
<pre lang="java" escaped="true">import java.util.*;
<p>public class Fruit
{
private static final Map&lt;String,Fruit&gt; types = new HashMap&lt;String,Fruit&gt;();
private final String type;</p>
<pre><code>// using a private constructor to force use of the factory method.
private Fruit(String type) {
  this.type = type;
}

/**
 * Lazy Factory method, gets the Fruit instance associated with a
 * certain type. Instantiates new ones as needed.
 * @param type Any string that describes a fruit type, e.g. &quot;apple&quot;
 * @return The Fruit instance associated with that type.
 */
public static synchronized Fruit getFruit(String type) {
  if(!types.containsKey(type))
    types.put(type, new Fruit(type)); // Lazy initialization
  return types.get(type);
}
</code></pre>
<p>}</pre></p>
<h2 id="heading"></h2>
<h2 id="对象池模式">对象池模式</h2>
<p>**场景：**创建实例的时间比较长
**使用：**一开始创建多个实例保存起来，每次用完之后还回池里。</p>
<h2 id="heading-1"></h2>
<h2 id="原型模式">原型模式</h2>
<p>**场景：**创建实例的成本比较高，复制实例的成本低。
使用：实现clone()这个方法，每个对象可以从自身克隆。python可以使用deepcopy()方法来拷贝。
<img src="http://images.cnblogs.com/cnblogs_com/wuyuegb2312/468244/o_ch6.%e5%8e%9f%e5%9e%8b%e6%a8%a1%e5%bc%8f.png" alt="">
 </p>
<pre lang="java" escaped="true">/** Prototype Class **/
public class Cookie implements Cloneable {

   public Object clone()
   {
       try{
           //In an actual implementation of this pattern you would now attach references to
           //the expensive to produce parts from the copies that are held inside the prototype.
           return this.getClass().newInstance();
       }
       catch(InstantiationException e)
       {
          e.printStackTrace();
          return null;
       }
   }
}

/** Concrete Prototypes to clone **/
public class CoconutCookie extends Cookie { }

/** Client Class**/
public class CookieMachine
{

  private Cookie cookie;//cookie必须是可复制的

    public CookieMachine(Cookie cookie) { 
        this.cookie = cookie; 
    } 
    public Cookie makeCookie() { 
      return (Cookie)cookie.clone(); 
    } 
    public Object clone() { } 

    public static void main(String args[]){ 
        Cookie tempCookie =  null; 
        Cookie prot = new CoconutCookie(); 
        CookieMachine cm = new CookieMachine(prot); //设置原型
        for(int i=0; i&lt;100; i++) 
            tempCookie = cm.makeCookie();//通过复制原型返回多个cookie 
    } 
}</pre>
<p> </p>
<h2 id="单例模式">单例模式</h2>
<p>**场景：**只需要创建一个实例，多个使用
**使用：**要注意<a href="http://blog.csdn.net/dl88250/article/details/5439024">Java 中的双重检查（Double-Check）</a>，可以使用在成员变量初始化、使用volatile变量、对方法sync
python单例例子：<a href="http://blog.csdn.net/ghostfromheaven/article/details/7671853">http://blog.csdn.net/ghostfromheaven/article/details/7671853</a>，python的模块（module）本身是单例的</p>
<pre lang="java" escaped="true">public class Singleton {
    private static volatile Singleton INSTANCE = null;

    // Private constructor suppresses 
    // default public constructor
    private Singleton() {}

    //thread safe and performance  promote 
    public static  Singleton getInstance() {
        if(INSTANCE == null){
             synchronized(Singleton.class){
                 //when more than two threads run into the first null check same time, to avoid instanced more than one time, it needs to be checked again.
                 if(INSTANCE == null){ 
                     INSTANCE = new Singleton();
                  }
              } 
        }
        return INSTANCE;
    }
  }</pre>
<h2 id="heading-2"></h2>
<h2 id="适配器模式">适配器模式</h2>
<p>**场景：**和客户需要的接口有差异
**使用：**构建一个Adapter实现客户需要的接口，把对应的方法映射到自己的类上（Adaptee）
<img src="http://images.cnblogs.com/cnblogs_com/wuyuegb2312/468244/o_ch13.%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f.png" alt=""></p>
<pre lang="python" escaped="true">class Target:
    def Request():
        print "common request."

class Adaptee(Target):
    def SpecificRequest(self):
        print "specific request."

class Adapter(Target):
    def __init__(self,ada):
        self.adaptee = ada
    def Request(self):
        self.adaptee.SpecificRequest()

if __name__ == "__main__":
    adaptee = Adaptee()
    adapter = Adapter(adaptee)
    adapter.Request()</pre>
<p> </p>
<h2 id="桥接模式-bridge">桥接模式 /Bridge</h2>
<p>**场景：**把抽象（abstraction）和实现（implementor）分离，两者可以独立变化
**使用：**Refined Abstraction是为了调用具体实现类
**实例：**不同的汽车有不同的引擎
参考代码见这里：<a href="http://blog.csdn.net/shaopeng5211/article/details/8827507">http://blog.csdn.net/shaopeng5211/article/details/8827507</a>
<img src="http://images.cnblogs.com/cnblogs_com/wuyuegb2312/468244/o_ch18.%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f.png" alt="">
 </p>
<h2 id="组合模式">组合模式</h2>
<p>**场景：**把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。
**实例：**公司人员结构
<img src="http://images.cnblogs.com/cnblogs_com/wuyuegb2312/468244/o_ch15.%e7%bb%84%e5%90%88%e6%a8%a1%e5%bc%8f.png" alt=""></p>
<pre lang="python" escaped="true">组合模式

class Component:
    def __init__(self,strName):
        self.m_strName = strName
    def Add(self,com):
        pass
    def Display(self,nDepth):
        pass

class Leaf(Component):
    def Add(self,com):
        print "leaf can't add"
    def Display(self,nDepth):
        strtemp = ""
        for i in range(nDepth):
            strtemp=strtemp+"-"
        strtemp=strtemp+self.m_strName
        print strtemp

class Composite(Component):
    def __init__(self,strName):
        self.m_strName = strName
        self.c = []
    def Add(self,com):
        self.c.append(com)
    def Display(self,nDepth):
        strtemp=""
        for i in range(nDepth):
            strtemp=strtemp+"-"
        strtemp=strtemp+self.m_strName
        print strtemp
        for com in self.c:
            com.Display(nDepth+2)

if __name__ == "__main__":
    p = Composite("Wong")
    p.Add(Leaf("Lee"))
    p.Add(Leaf("Zhao"))
    p1 = Composite("Wu")
    p1.Add(Leaf("San"))
    p.Add(p1)
    p.Display(1);</pre>
<p> </p>
<h2 id="装饰模式decorator"><strong>装饰模式/Decorator</strong></h2>
<p>装饰（ Decorator ）模式又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案。
**场景：**对类扩展方法
**代码：**<a href="http://blog.csdn.net/shaopeng5211/article/details/8803120">http://blog.csdn.net/shaopeng5211/article/details/8803120</a>
<img src="http://images.cnblogs.com/cnblogs_com/wuyuegb2312/468244/o_ch3.%e8%a3%85%e9%a5%b0%e6%a8%a1%e5%bc%8f.png" alt="">
 </p>
<h2 id="外观模式facadec">外观模式/Facadec</h2>
<p>**场景：**为client提供简单的方法，调用具体的多个实现类
<strong>代码</strong>：<a href="http://blog.csdn.net/shaopeng5211/article/details/8813135">http://blog.csdn.net/shaopeng5211/article/details/8813135</a>
<img src="http://img.my.csdn.net/uploads/201304/17/1366170463_6144.png" alt="">
 </p>
<h2 id="享元模式flyweight">享元模式/Flyweight</h2>
<p>采用一个共享来避免大量拥有相同内容对象的开销。这种开销中最常见、直观的就是内存的损耗。享元模式以共享的方式高效的支持大量的细粒度对象。
** **</p>
<h2 id="代理模式proxy">代理模式/Proxy</h2>
<p>所谓代理，是指具有与代理元（被代理的对象）具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一般在交互的过程中（交互前后），进行某些特别的处理。
需要与继承区分，继承是静态的增加方法，代理可以实现一些纵切的功能。
<img src="http://images.cnblogs.com/cnblogs_com/wuyuegb2312/468244/o_ch.4%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f.png" alt="">
 </p>
<h2 id="firstHeading" lang="zh-CN">  职责链模式/Chain of Responsibility</h2>
该模式构造一系列分别担当不同的职责的类的对象来共同完成一个任务，这些类的对象之间像链条一样紧密相连，所以被称作职责链模式。
**场景：**如一件事需要多个部门处理，这个部门处理完交给下个部门。
**使用：**每个对象设定下一个处理的对象是什么，并且在handle方法里调用下一个处理的方法。
**代码：**<http://blog.csdn.net/shaopeng5211/article/details/8857776>
&nbsp;
## 命令模式/Command
<p>命令物件可以把行动(action) 及其参数封装起来，可以重复执行、取消。
<img src="http://upload.wikimedia.org/wikipedia/commons/8/8e/Command_Design_Pattern_Class_Diagram.png" alt="Command Design Pattern Class Diagram.png">
Command                           Command抽象类。<br>
ConcreteCommand        Command的具体实现类。<br>
Receiver                             需要被调用的目标对象。<br>
Invorker                             通过Invorker执行Command对象。</p>
<pre lang="java" escaped="true">import java.util.List;
import java.util.ArrayList;

/* The Command interface */
public interface Command {
   void execute();
}

/* The Invoker class */
public class Switch {
   private List&lt;Command&gt; history = new ArrayList&lt;Command&gt;();

   public Switch() {
   }

   public void storeAndExecute(Command cmd) {
      this.history.add(cmd); // optional 
      cmd.execute();        
   }
}

/* The Receiver class */
public class Light {
   public Light() {
   }

   public void turnOn() {
      System.out.println("The light is on");
   }

   public void turnOff() {
      System.out.println("The light is off");
   }
}

/* The Command for turning on the light - ConcreteCommand #1 */
public class FlipUpCommand implements Command {
   private Light theLight;

   public FlipUpCommand(Light light) {
      this.theLight = light;
   }

   public void execute(){
      theLight.turnOn();
   }
}

/* The Command for turning off the light - ConcreteCommand #2 */
public class FlipDownCommand implements Command {
   private Light theLight;

   public FlipDownCommand(Light light) {
      this.theLight = light;
   }

   public void execute() {
      theLight.turnOff();
   }
}

/* The test class or client */
public class PressSwitch {
   public static void main(String[] args){
      Light lamp = new Light();
      Command switchUp = new FlipUpCommand(lamp);
      Command switchDown = new FlipDownCommand(lamp);

      Switch mySwitch = new Switch();

      try {
         if ("ON".equalsIgnoreCase(args[0])) {
            mySwitch.storeAndExecute(switchUp);
         }
         else if ("OFF".equalsIgnoreCase(args[0])) {
            mySwitch.storeAndExecute(switchDown);
         }
         else {
            System.out.println("Argument \"ON\" or \"OFF\" is required.");
         }
      } catch (Exception e) {
         System.out.println("Arguments required.");
      }
   }
}</pre>
<p> </p>
<h2 id="解释器模式interpreter">解释器模式/Interpreter</h2>
<p>它建立一个解释器，对于特定的计算机程序设计语言，用来解释预先定义的文法。简单地说，Interpreter模式是一种简单的语法解释器构架。
<img src="http://img.my.csdn.net/uploads/201304/25/1366854216_4860.png" alt="">
Context 解释器上下文环境类。用来存储解释器的上下文环境，比如需要解释的文法等。<br>
AbstractExpression 解释器抽象类。<br>
ConcreteExpression 解释器具体实现类
**代码：**<a href="http://blog.csdn.net/shaopeng5211/article/details/8847991">http://blog.csdn.net/shaopeng5211/article/details/8847991</a>
 </p>
<h2 id="迭代器">迭代器</h2>
<p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
 </p>
<h2 id="中介者模式">中介者模式</h2>
<p>**场景：**有多个类需要交互，由中介来调用他们。但中介者会变得复杂。
<a href="http://haolloyin.blog.51cto.com/1177454/333810">http://haolloyin.blog.51cto.com/1177454/333810</a>
 </p>
<h2 id="备忘录模式">备忘录模式</h2>
<p>用另一个结构一样的类把变量存储起来。。o(╯□╰)o，可以在某个时间还原。
<a href="http://blog.csdn.net/shaopeng5211/article/details/8879519">http://blog.csdn.net/shaopeng5211/article/details/8879519</a>
 </p>
<h2 id="观察者模式">观察者模式</h2>
<p>**场景：**一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。
**使用：**Subject提供注册、删除、通知的方法，Observer注册到Subject，Subject状态变化时，就会通知所有注册的Observer。
**代码：**<a href="http://zh.wikipedia.org/wiki/观察者模式" target="_blank"><a href="http://zh.wikipedia.org/wiki/">http://zh.wikipedia.org/wiki/</a>观察者模式</a>
<img src="http://upload.wikimedia.org/wikipedia/commons/e/e2/Observer-pattern-class-diagram.png" alt="Observer-pattern-class-diagram.png">
 
 </p>
<h2 id="状态模式">状态模式</h2>
<p>State模式允许通过改变对象的内部状态而改变对象的行为，这个对象表现得就好像修改了它的类一样。
**使用：**Context维护一个state变量，并且使用这个state的方法。但state变更时，方法自然也变了。
<img src="http://img.blog.csdn.net/20130504100850466" alt="">
 
 </p>
<h2 id="策略模式">策略模式</h2>
<p>策略模式作为一种<a href="http://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F" title="软件设计模式">软件设计模式</a>，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。
**使用：**新建不同的策略让Context调用，需要与状态模式区分，状态模式的迁移对客户是透明的。
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Strategy_Pattern_Diagram_ZP.svg/500px-Strategy_Pattern_Diagram_ZP.svg.png" alt="">
 </p>
<h2 id="模板模式">模板模式</h2>
<p><strong>模板方法模式</strong>定义了一个<a href="http://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95" title="算法">算法</a>的步骤，并允许次类别为一个或多个步骤提供其实践方式。
<a href="http://zh.wikipedia.org/wiki/模板模式" target="_blank"><a href="http://zh.wikipedia.org/wiki/">http://zh.wikipedia.org/wiki/</a>模板模式</a>
 </p>
<h2 id="访问者模式">访问者模式</h2>
<p>把对象和算法分开，通过使用回调的方式。对象实现accept方法，传入vistor调用它的方法。
<a href="http://zh.wikipedia.org/wiki/访问者模式" target="_blank"><a href="http://zh.wikipedia.org/wiki/">http://zh.wikipedia.org/wiki/</a>访问者模式</a>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Visitor_UML_class_diagram.svg/624px-Visitor_UML_class_diagram.svg.png" alt="File:Visitor UML class diagram.svg"></p>
<h2 id="参考">参考</h2>
<p><a href="http://www.cnblogs.com/wuyuegb2312/archive/2013/04/09/3008320.html">http://www.cnblogs.com/wuyuegb2312/archive/2013/04/09/3008320.html</a>
<a href="http://blog.csdn.net/shaopeng5211">http://blog.csdn.net/shaopeng5211/</a>
<a href="http://zh.wikipedia.org/zh-cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" title="http://zh.wikipedia.org/zh-cn/设计模式_(计算机)">http://zh.wikipedia.org/zh-cn/设计模式_(计算机)</a></p>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">fatkun</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2013-09-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2013/10/maven-nexus.html">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">在windows部署nexus编译hadoop cdh4.3</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2013/08/install-pylibmc.html">
            <span class="next-text nav-default">安装pylibmc</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/fatkun" class="iconfont icon-github" title="github"></a>
  <a href="https://fatkun.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2009 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>fatkun</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
